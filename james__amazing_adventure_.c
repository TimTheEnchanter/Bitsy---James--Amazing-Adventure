// Converted to SDCC + LibCV by Bitsy-Converter

#include <stdlib.h>
#include <string.h>
#include <cv.h>
#include <cvu.h>

#define BGCOL CV_COLOR_BLUE

#define ROOM_COLS 16
#define ROOM_ROWS 16
#define ROOM_X_OFS ((COLS - ROOM_COLS) >> 1)
#define ROOM_Y_OFS ((ROWS - ROOM_ROWS) >> 1)
#define FIRST_TILE 128

#define DLG_COLS 28
#define DLG_X_OFS ((COLS - DLG_COLS) >> 1)
#define DLG_Y_OFS 2


enum ImageOffset {
  ofs_BLANK = 0,
  ofs_TIL_a = 1,
  ofs_TIL_b = 2,
  ofs_TIL_c = 3,
  ofs_TIL_d = 4,
  ofs_TIL_e = 5,
  ofs_TIL_f = 6,
  ofs_TIL_g = 7,
  ofs_TIL_h = 8,
  ofs_TIL_i = 10,
  ofs_SPR_A = 12,
  ofs_SPR_a = 14,
  ofs_SPR_b = 15,
  ofs_ITM_0 = 17,
  ofs_ITM_1 = 18
};


typedef struct {
    uint8_t image;
    uint8_t x, y;
    void  (*dialog)();
} BitsySprite;

typedef struct {
  bool isWall;
  uint8_t frameCount;
} TileInfo;

typedef struct {
  uint8_t origX, origY;
  uint8_t destX, destY;
  uint8_t destRoom;
} Exit;

typedef struct {
  uint8_t x, y;
  void  (*dialog)();
} Ending;

typedef struct Room {
    uint8_t tileMap[16][16];
    
    uint8_t spriteCount;
    BitsySprite *sprites;
    
    uint8_t exitCount;
    Exit *exits;
    
    uint8_t endingCount;
    Ending *endings;
} Room;

void showDialog(char *s);


const uint8_t FRAME_COUNT = 19;

const char gameTitle[] = "James' Amazing Adventure ";

const BitsySprite playerSpriteStart = { ofs_SPR_A, 6, 7 };

void dialog_0() {
  showDialog("I'm a cat");  
}

void dialog_1() {
  showDialog("You found a nice warm cup of tea");  
}

void dialog_2() {
  showDialog("A key! ");
  /* Unknown command: block name=undefined mode=code */
  showDialog("What does it open?");
  /* Unknown command: block name=undefined mode=code */  
}

void dialog_3() {
  showDialog("How does that cat manage to operate a radio without opposable thumbs?");  
}



const BitsySprite room_0_sprites[] = {
  { ofs_SPR_a, 8, 12, dialog_0 },
  { ofs_SPR_b, 3, 8, dialog_3 }
};

const BitsySprite room_1_sprites[] = {{0}};

const Exit room_0_exits[] = {
  { 7, 0, 7, 0, 1 },
  { 8, 0, 8, 0, 1 }
};

const Exit room_1_exits[] = {
  { 7, 0, 7, 0, 0 },
  { 8, 0, 8, 0, 0 }
};

const Ending room_0_endings[] = {{0}};

const Ending room_1_endings[] = {{0}};

const Room rooms[] = {

  // Room 0
  {{
    { 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4 },
    { 4, 4, 4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 4, 4, 4 },
    { 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4 },
    { 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4 },
    { 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4 },
    { 4, 4, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 4, 4 },
    { 4, 4, 8, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 8, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 }
  }, 2, room_0_sprites, 2, room_0_exits, 0, room_0_endings}
,
  // Room 1
  {{
    { 4, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4 },
    { 4, 4, 4, 4, 4, 4, 4, 7, 7, 4, 4, 4, 4, 4, 4, 4 },
    { 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4 },
    { 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 4, 4 },
    { 4, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4 },
    { 4, 4, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 4, 4 },
    { 4, 4, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 },
    { 4, 4, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 6, 4, 4 },
    { 4, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 4, 4 }
  }, 0, room_1_sprites, 2, room_1_exits, 0, room_1_endings}

};

const TileInfo tileInfos[] = {
  // BLANK
  { false, 1 },
  // TIL_a
  { false, 1 },
  // TIL_b
  { false, 1 },
  // TIL_c
  { true, 1 },
  // TIL_d
  { true, 1 },
  // TIL_e
  { false, 1 },
  // TIL_f
  { false, 1 },
  // TIL_g
  { false, 1 },
  // TIL_h
  { false, 2 },
  { false, 2 },
  // TIL_i
  { false, 2 },
  { false, 2 },
  // SPR_A
  { false, 2 },
  { false, 2 },
  // SPR_a
  { false, 1 },
  // SPR_b
  { false, 2 },
  { false, 2 },
  // ITM_0
  { false, 1 },
  // ITM_1
  { false, 1 }
};

const uint8_t images[][8] = { 

  // BLANK: index 0, offset 0, 1 frame(s)
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  // TIL_a: index 1, offset 1, 1 frame(s)
  { 0xFF, 0x81, 0x81, 0x99, 0x99, 0x81, 0x81, 0xFF },
  // TIL_b: index 2, offset 2, 1 frame(s)
  { 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0x18, 0x18, 0x18 },
  // TIL_c: index 3, offset 3, 1 frame(s)
  { 0x20, 0x40, 0x80, 0xFF, 0x81, 0xBD, 0x81, 0x7E },
  // TIL_d: index 4, offset 4, 1 frame(s)
  { 0xFF, 0x12, 0xFF, 0x48, 0xFF, 0x12, 0xFF, 0x48 },
  // TIL_e: index 5, offset 5, 1 frame(s)
  { 0xFF, 0x81, 0x81, 0x81, 0x81, 0x81, 0x81, 0xFF },
  // TIL_f: index 6, offset 6, 1 frame(s)
  { 0xAA, 0x44, 0x00, 0xAA, 0x11, 0x00, 0x55, 0x22 },
  // TIL_g: index 7, offset 7, 1 frame(s)
  { 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0xFF },
  // TIL_h: index 8, offset 8, 2 frame(s)
  { 0x6A, 0x7E, 0x3C, 0xFF, 0x7E, 0x18, 0x18, 0x7E },
  { 0x56, 0x7E, 0x3C, 0xFF, 0x7E, 0x18, 0x18, 0x7E },
  // TIL_i: index 9, offset 10, 2 frame(s)
  { 0x00, 0x00, 0x04, 0x0C, 0x14, 0x24, 0x42, 0x56 },
  { 0x00, 0x04, 0x0C, 0x14, 0x24, 0x44, 0x42, 0x6A },
  // SPR_A: index 10, offset 12, 2 frame(s)
  { 0x18, 0x38, 0x18, 0x3C, 0x7E, 0x99, 0x24, 0x66 },
  { 0x18, 0x38, 0x18, 0x3C, 0x7E, 0x99, 0x24, 0x24 },
  // SPR_a: index 11, offset 14, 1 frame(s)
  { 0x00, 0x00, 0x51, 0x71, 0x72, 0x7C, 0x3C, 0x24 },
  // SPR_b: index 12, offset 15, 2 frame(s)
  { 0x38, 0x74, 0x64, 0x64, 0x58, 0x1C, 0x18, 0x28 },
  { 0x38, 0x74, 0x64, 0x64, 0x98, 0x1C, 0x18, 0x28 },
  // ITM_0: index 13, offset 17, 1 frame(s)
  { 0x00, 0x00, 0x00, 0x3C, 0x64, 0x24, 0x18, 0x00 },
  // ITM_1: index 14, offset 18, 1 frame(s)
  { 0x00, 0x3C, 0x24, 0x3C, 0x10, 0x18, 0x10, 0x18 } 
};


const uint8_t BUTTON_REPEAT_RATE = 8;

bool startingGame = false;
uint8_t currentLevel = 0;
uint8_t buttonDelay = 0;
uint8_t scrollY = 0;
uint8_t targetScrollY = 0;
bool needUpdate = true;
BitsySprite playerSprite;
uint16_t frameControl = 0;
uint8_t frameDelay = 0;

void  (*currentDialog)() = NULL;
void  (*currentEnding)() = NULL;



/* VRAM map
   0x0000 - 0x17ff character pattern table
   0x1800 - 0x1aff image table
   0x2000 - 0x37ff color table
   0x3800 - 0x3bff sprite pattern table
   0x3c00 - 0x3fff sprite attribute table
*/
 
#define PATTERN		((const cv_vmemp)0x0000)
#define IMAGE		((const cv_vmemp)0x1800)
#define COLOR		((const cv_vmemp)0x2000)
#define SPRITE_PATTERNS ((const cv_vmemp)0x3800)
#define SPRITES		((const cv_vmemp)0x3c00)

#ifndef COLS
#define COLS 32
#endif

#ifndef ROWS
#define ROWS 24
#endif

#define wait_vsync() __asm__("halt")

const uint8_t font_bitmap[] = {
// Character ' '
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 32
0x10,0x38,0x38,0x10,0x10,0x00,0x10,0x00, // 33
0x6c,0x6c,0x48,0x00,0x00,0x00,0x00,0x00, // 34
0x00,0x28,0x7c,0x28,0x28,0x7c,0x28,0x00, // 35
0x20,0x38,0x40,0x30,0x08,0x70,0x10,0x00, // 36
0x64,0x64,0x08,0x10,0x20,0x4c,0x4c,0x00, // 37
0x20,0x50,0x50,0x20,0x54,0x48,0x34,0x00, // 38
0x30,0x30,0x20,0x00,0x00,0x00,0x00,0x00, // 39
0x10,0x20,0x20,0x20,0x20,0x20,0x10,0x00, // 40
0x20,0x10,0x10,0x10,0x10,0x10,0x20,0x00, // 41
0x00,0x28,0x38,0x7c,0x38,0x28,0x00,0x00, // 42
0x00,0x10,0x10,0x7c,0x10,0x10,0x00,0x00, // 43
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x20, // 44
0x00,0x00,0x00,0x7c,0x00,0x00,0x00,0x00, // 45
0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00, // 46
0x00,0x04,0x08,0x10,0x20,0x40,0x00,0x00, // 47
// Character 0
0x38,0x44,0x4c,0x54,0x64,0x44,0x38,0x00, // 48
0x10,0x30,0x10,0x10,0x10,0x10,0x38,0x00, // 49
0x38,0x44,0x04,0x18,0x20,0x40,0x7c,0x00, // 50
0x38,0x44,0x04,0x38,0x04,0x44,0x38,0x00, // 51
0x08,0x18,0x28,0x48,0x7c,0x08,0x08,0x00, // 52
0x7c,0x40,0x40,0x78,0x04,0x44,0x38,0x00, // 53
0x18,0x20,0x40,0x78,0x44,0x44,0x38,0x00, // 54
0x7c,0x04,0x08,0x10,0x20,0x20,0x20,0x00, // 55
0x38,0x44,0x44,0x38,0x44,0x44,0x38,0x00, // 56
0x38,0x44,0x44,0x3c,0x04,0x08,0x30,0x00, // 57
0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x00, // 58
0x00,0x00,0x30,0x30,0x00,0x30,0x30,0x20, // 59
0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00, // 60
0x00,0x00,0x7c,0x00,0x00,0x7c,0x00,0x00, // 61
0x20,0x10,0x08,0x04,0x08,0x10,0x20,0x00, // 62
0x38,0x44,0x04,0x18,0x10,0x00,0x10,0x00, // 63
0x38,0x44,0x5c,0x54,0x5c,0x40,0x38,0x00, // 64
// Character A
0x38,0x44,0x44,0x44,0x7c,0x44,0x44,0x00, // 65
0x78,0x44,0x44,0x78,0x44,0x44,0x78,0x00, // 66
0x38,0x44,0x40,0x40,0x40,0x44,0x38,0x00, // 67
0x78,0x44,0x44,0x44,0x44,0x44,0x78,0x00, // 68
0x7c,0x40,0x40,0x78,0x40,0x40,0x7c,0x00, // 69
0x7c,0x40,0x40,0x78,0x40,0x40,0x40,0x00, // 70
0x38,0x44,0x40,0x5c,0x44,0x44,0x3c,0x00, // 71
0x44,0x44,0x44,0x7c,0x44,0x44,0x44,0x00, // 72
0x38,0x10,0x10,0x10,0x10,0x10,0x38,0x00, // 73
0x04,0x04,0x04,0x04,0x44,0x44,0x38,0x00, // 74
0x44,0x48,0x50,0x60,0x50,0x48,0x44,0x00, // 75
0x40,0x40,0x40,0x40,0x40,0x40,0x7c,0x00, // 76
0x44,0x6c,0x54,0x44,0x44,0x44,0x44,0x00, // 77
0x44,0x64,0x54,0x4c,0x44,0x44,0x44,0x00, // 78
0x38,0x44,0x44,0x44,0x44,0x44,0x38,0x00, // 79
0x78,0x44,0x44,0x78,0x40,0x40,0x40,0x00, // 80
0x38,0x44,0x44,0x44,0x54,0x48,0x34,0x00, // 81
0x78,0x44,0x44,0x78,0x48,0x44,0x44,0x00, // 82
0x38,0x44,0x40,0x38,0x04,0x44,0x38,0x00, // 83
0x7c,0x10,0x10,0x10,0x10,0x10,0x10,0x00, // 84
0x44,0x44,0x44,0x44,0x44,0x44,0x38,0x00, // 85
0x44,0x44,0x44,0x44,0x44,0x28,0x10,0x00, // 86
0x44,0x44,0x54,0x54,0x54,0x54,0x28,0x00, // 87
0x44,0x44,0x28,0x10,0x28,0x44,0x44,0x00, // 88
0x44,0x44,0x44,0x28,0x10,0x10,0x10,0x00, // 89
0x78,0x08,0x10,0x20,0x40,0x40,0x78,0x00, // 90
0x38,0x20,0x20,0x20,0x20,0x20,0x38,0x00, // 91
0x00,0x40,0x20,0x10,0x08,0x04,0x00,0x00, // 92
0x38,0x08,0x08,0x08,0x08,0x08,0x38,0x00, // 93
0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x00, // 94
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc, // 95
0x30,0x30,0x10,0x00,0x00,0x00,0x00,0x00, // 96
0x00,0x00,0x38,0x04,0x3c,0x44,0x3c,0x00, // 97
0x40,0x40,0x78,0x44,0x44,0x44,0x78,0x00, // 98
0x00,0x00,0x38,0x44,0x40,0x44,0x38,0x00, // 99
0x04,0x04,0x3c,0x44,0x44,0x44,0x3c,0x00, // 100
0x00,0x00,0x38,0x44,0x78,0x40,0x38,0x00, // 101
0x18,0x20,0x20,0x78,0x20,0x20,0x20,0x00, // 102
0x00,0x00,0x3c,0x44,0x44,0x3c,0x04,0x38, // 103
0x40,0x40,0x70,0x48,0x48,0x48,0x48,0x00, // 104
0x10,0x00,0x10,0x10,0x10,0x10,0x18,0x00, // 105
0x08,0x00,0x18,0x08,0x08,0x08,0x48,0x30, // 106
0x40,0x40,0x48,0x50,0x60,0x50,0x48,0x00, // 107
0x10,0x10,0x10,0x10,0x10,0x10,0x18,0x00, // 108
0x00,0x00,0x68,0x54,0x54,0x44,0x44,0x00, // 109
0x00,0x00,0x70,0x48,0x48,0x48,0x48,0x00, // 110
0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00, // 111
0x00,0x00,0x78,0x44,0x44,0x44,0x78,0x40, // 112
0x00,0x00,0x3c,0x44,0x44,0x44,0x3c,0x04, // 113
0x00,0x00,0x58,0x24,0x20,0x20,0x70,0x00, // 114
0x00,0x00,0x38,0x40,0x38,0x04,0x38,0x00, // 115
0x00,0x20,0x78,0x20,0x20,0x28,0x10,0x00, // 116
0x00,0x00,0x48,0x48,0x48,0x58,0x28,0x00, // 117
0x00,0x00,0x44,0x44,0x44,0x28,0x10,0x00, // 118
0x00,0x00,0x44,0x44,0x54,0x7c,0x28,0x00, // 119
0x00,0x00,0x48,0x48,0x30,0x48,0x48,0x00, // 120
0x00,0x00,0x48,0x48,0x48,0x38,0x10,0x60, // 121
0x00,0x00,0x78,0x08,0x30,0x40,0x78,0x00, // 122
0x18,0x20,0x20,0x60,0x20,0x20,0x18,0x00, // 123
0x10,0x10,0x10,0x00,0x10,0x10,0x10,0x00, // 124
0x30,0x08,0x08,0x0c,0x08,0x08,0x30,0x00, // 125
0x28,0x50,0x00,0x00,0x00,0x00,0x00,0x00, // 126
0x10,0x38,0x6c,0x44,0x44,0x7c,0x00,0x00, // 127
};
 
volatile uint_fast8_t vint_counter;

void vint_handler(void) {
  vint_counter++;
}

void vdp_setup() {
  cv_set_screen_active(false);
  cv_set_screen_mode(CV_SCREENMODE_STANDARD);
  cv_set_image_table(IMAGE);
  cv_set_character_pattern_t(PATTERN);
  cv_set_color_table(COLOR);
  cv_set_sprite_pattern_table(SPRITE_PATTERNS);
  cv_set_sprite_attribute_table(SPRITES);
  cv_set_sprite_big(true);
}

void setupGraphics() {
#ifndef CV_MSX
  cvu_memtovmemcpy(PATTERN + 8*' ', font_bitmap, 0x800);
#endif

#ifndef CV_MSX
  cvu_vmemset(COLOR, 0x30|BGCOL, 8); // set color for chars 0-63
  cvu_vmemset(COLOR+8, 0x0|BGCOL, 32-8); // set chars 63-255
  cvu_vmemset(COLOR+16, 0xb0|BGCOL, 1); // set chars 128-128+8
#endif

  // Prepare blank tile 0
  cvu_memtovmemcpy(PATTERN, images[0], 8);
  
  // Load the images as chars
  cvu_memtovmemcpy(PATTERN+8*FIRST_TILE, images[0], 8 * FRAME_COUNT);
  cvu_memtovmemcpy(SPRITE_PATTERNS, images[0], 8 * FRAME_COUNT);
}

uint8_t frameNumber(uint8_t tn) {
  uint8_t frameCount = tileInfos[tn].frameCount;
  return frameCount > 1 ? frameControl % frameCount : 0;
}

void drawSprite(uint8_t sprNumber, BitsySprite *spr) {
  struct cvu_sprite sprite;

  cvu_set_sprite_x(&sprite, (spr->x + ROOM_X_OFS) * 8);
  cvu_set_sprite_y(&sprite, (spr->y + ROOM_Y_OFS) * 8);
  cvu_set_sprite_color(&sprite, CV_COLOR_WHITE);
  sprite.name = spr->image + frameNumber(spr->image);
  cvu_set_sprite(SPRITES, sprNumber, &sprite); 
}

void finishSpriteList(uint8_t sprNumber) {
  struct cvu_sprite sprite;
  // If Y is 208, that sprite and all following sprites in the table are not  displayed.
  sprite.y = 208;
  cvu_set_sprite(SPRITES, sprNumber, &sprite); 
}

void clearDisplay() {
  cvu_vmemset(IMAGE, 0, COLS * ROWS);
  finishSpriteList(0);
}

void drawBackground() {
  char buf[COLS];

  for (uint16_t i = 0; i != ROOM_ROWS; i++) {
    for (uint8_t j = 0; j != ROOM_COLS; j++) {
      uint8_t tileNumber = rooms[currentLevel].tileMap[i][j];
      buf[j] = tileNumber + frameNumber(tileNumber) + FIRST_TILE;
    }
    cvu_memtovmemcpy(IMAGE + ROOM_X_OFS + COLS * (ROOM_Y_OFS + i), buf, ROOM_COLS);
  }
}

void drawSprites() { 
  uint8_t sprNumber = 0;
  drawSprite(sprNumber++, &playerSprite);
  
  for (uint8_t i = 0; i < rooms[currentLevel].spriteCount; i++) { 
    BitsySprite *spr = &rooms[currentLevel].sprites[i]; 
    drawSprite(sprNumber++, spr);
  }
  
  finishSpriteList(sprNumber);
}

void showDialog(char *s) {
  struct cv_controller_state ctrl;
  char buf[DLG_COLS];
  uint16_t vaddr = IMAGE + DLG_X_OFS + COLS * DLG_Y_OFS; 
  uint8_t counter = 0;  
 
  // Draw text
  for (char *p = s; *p; vaddr += COLS) {
    for (uint8_t j = 0; j != DLG_COLS; j++) {
      buf[j] = *p;
      if (*p) {
        p++;
      }
    }
    cvu_memtovmemcpy(vaddr, buf, DLG_COLS);
  }
  
  // Wait button press
  do {
    wait_vsync();
    cv_get_controller_state(&ctrl, 0); 
    cvu_vmemset(vaddr + DLG_COLS - 1, counter & 0x20 ? ' ' : '_', 1);
    counter++;
  } while (!(ctrl.joystick & (CV_FIRE_0 | CV_FIRE_1)));
  
  // Wait button release
  do {
    wait_vsync();
    cv_get_controller_state(&ctrl, 0); 
  } while (ctrl.joystick & (CV_FIRE_0 | CV_FIRE_1));
  
  // Clear screen
  clearDisplay();
  needUpdate = true;
}

bool tryMovingPlayer(int8_t dx, uint8_t dy) {
  // Calculate where the player will try to move to
  uint8_t x = playerSprite.x + dx;
  uint8_t y = playerSprite.y + dy;
  uint8_t tn;

  // Out of bounds  
  if (x > 15 || y > 15) {
    return false;
  }

  // Check if there are background tiles in the way
  tn = rooms[currentLevel].tileMap[y][x];
  if (tn && tileInfos[tn].isWall) {
    return false;
  }
  
  // Check collision against the sprites
  for (uint8_t i = 0; i != rooms[currentLevel].spriteCount; i++) {
    BitsySprite *spr = &rooms[currentLevel].sprites[i];
    if (spr->x == x && spr->y == y) {
      currentDialog = spr->dialog;
      return true;
    }
  }
    
  // Check collision against the exits
  for (uint8_t i = 0; i != rooms[currentLevel].exitCount; i++) {
    Exit *ext = &rooms[currentLevel].exits[i];
    
    if (ext->origX == x && ext->origY == y) {
      playerSprite.x = ext->destX;
      playerSprite.y = ext->destY;
      currentLevel = ext->destRoom; 
      
      return true;
    }
  }
    
  // Check collision against the endings
  for (uint8_t i = 0; i != rooms[currentLevel].endingCount; i++) {
    Ending *edg = &rooms[currentLevel].endings[i];
    if (edg->x == x && edg->y == y) {
      currentEnding = edg->dialog; 
      return true;
    }
  }

  // No obstacles found: the player can move.
  playerSprite.x = x;
  playerSprite.y = y;
  
  return true;
}

bool controlPlayer() {
  struct cv_controller_state ctrl;
  cv_get_controller_state(&ctrl, 0); 
  
  if (ctrl.joystick & CV_UP) {
    return tryMovingPlayer(0, -1);
  }
  if (ctrl.joystick & CV_DOWN) {
    return tryMovingPlayer(0, 1);
  }
  if (ctrl.joystick & CV_LEFT) {
    return tryMovingPlayer(-1, 0);
  }
  if (ctrl.joystick & CV_RIGHT) {
    return tryMovingPlayer(1, 0);
  }
  
  return false;
}

void startGame() { 
  clearDisplay();
  showDialog(gameTitle);

  playerSprite.image = playerSpriteStart.image;
  playerSprite.x = playerSpriteStart.x;
  playerSprite.y = playerSpriteStart.y;
  
  frameControl = 0;
  frameDelay = 0;
   
  currentLevel = 0;
  
  scrollY = 0;
  targetScrollY = 0;

  currentDialog = NULL;
  currentEnding = NULL;

  startingGame = false;
  needUpdate = true;
}

void endGame() {
  clearDisplay();
  (*currentEnding)();
  currentEnding = NULL;
    
  startingGame = true;
  needUpdate = true;
}

void main() {
  vdp_setup();
  cv_set_sprite_big(false);

  setupGraphics();
  cv_set_screen_active(true);
  cv_set_vint_handler(&vint_handler);  
  
  startingGame = true;

  for (;;) { 
    wait_vsync();
    
    // Display title screen if necessary
    if (startingGame) {
      startGame();
    }
    
    // Increment frame control for animations  
    if (frameDelay) {
      frameDelay--;
    } else {
      frameControl++;
      frameDelay = 30;
      needUpdate = true;
    }

    // Wait between keypresses
    if (buttonDelay > 0) {
      buttonDelay--;
    } else {
      if (controlPlayer()) {
        buttonDelay = BUTTON_REPEAT_RATE;
        needUpdate = true;
      }
    }
     
    if (needUpdate) {
      drawBackground();
      drawSprites();
      
      needUpdate = false; 
    }
  
    if (currentDialog) {
      (*currentDialog)();
      currentDialog = NULL;
      needUpdate = true;
    }

  
    if (currentEnding) {
      endGame();
    }
  }
  
}
